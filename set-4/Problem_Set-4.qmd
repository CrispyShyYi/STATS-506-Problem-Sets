---
title: "Problem Set 4"
author: "Jialiang Wu"
format:
  html:
    theme: default
    page-layout: article
    code-fold: true
    code-summary: "Show the code"
    embed-resources: true
editor: visual
---


For source files and data, see my GitHub repo: [STATS-506-Problem-Sets-04](https://github.com/CrispyShyYi/STATS-506-Problem-Sets/tree/main/set-4)

## Set Up
```{r setup tidyverse}
library(tidyverse)
library(scales)
library(ggplot2)
```

## Question 1

### load `nzelect`
```{r setup_question1}
library(nzelect)
data("nzge")
# stick within tidyverse
nzge <- as_tibble(nzge)
```

### question 1-a
```{r q1a}
# group by year and type
vote_summary <- nzge %>%
  group_by(election_year, voting_type) %>%
  summarize(total_votes = sum(votes, na.rm = TRUE)) %>%
  arrange(desc(total_votes)) %>%   # sort by vote count
  ungroup()

# display output
vote_summary
```

### question 1-b
```{r rq1b}
candidate_2014 <- nzge %>%
  filter(election_year == 2014, voting_type == "Candidate") %>%
  group_by(party) %>%
  summarise(total_votes = sum(votes, na.rm = TRUE)) %>%
  mutate(percent = round(total_votes / sum(total_votes) * 100, 3)) %>%
  arrange(desc(percent)) %>%
  ungroup()

# display result
candidate_2014
```

### question 1-c
```{r q1c}
winners <- nzge %>%
  group_by(election_year, voting_type, party) %>%
  summarise(total_votes = sum(votes, na.rm = TRUE), .groups = "drop_last") %>%
  slice_max(total_votes, n = 1, with_ties = FALSE) %>%
  pivot_wider(
    id_cols = election_year,
    names_from = voting_type,
    values_from = party,
    names_prefix = "winner_"
  ) %>%
  arrange(election_year)

# display result
winners
```

\newpage

## Question 2

### load ATP Matches data
```{r load data}
ATP <- readr::read_delim("https://raw.githubusercontent.com/JeffSackmann/tennis_atp/refs/heads/master/atp_matches_2019.csv", show_col_types = FALSE)
```

### question 2-a
In the ATP Matches dataset, the Davis Cup is recorded differently from regular ATP tournaments.
Each Davis Cup tie (e.g., France vs Japan, Spain vs Russia) is assigned its own tourney_id.
This means that if we simply count distinct(tourney_id), the Davis Cup will appear as many separate tournaments, which would artificially inflate the number of tournaments in 2019.

To address this, we need to group all tourney_id values that belong to the Davis Cup (those containing "2019-M-DC") and treat them as one single tournament.
For the rest of the tournaments, we can safely count distinct tourney_id values directly.

Thus, the total number of tournaments in 2019 is calculated as:

Number of tournaments = distinct non–Davis Cup tourney_ids + 1 (for Davis Cup)

```{r q2a}
# Split into Davis Cup vs others
davis_ids <- ATP %>%
  filter(grepl("2019-M-DC", tourney_id)) %>%
  distinct(tourney_id)

other_ids <- ATP %>%
  filter(!grepl("2019-M-DC", tourney_id)) %>%
  distinct(tourney_id)

# Final tournament count: all others + 1 for Davis Cup
n_tournaments <- nrow(other_ids) + 1

n_tournaments
```

**Answer:** There are 128 tournaments took place in 2019

### question 2-b
The Laver Cup (tournament_id: 2019-9210)  is a special team exhibition event (Team Europe vs Team World).
Unlike standard ATP tournaments, it does not have a single final match (round == "F") that produces an individual player champion. Also, the Davis Cup is a national team competition, not an individual tournament, which means the winner is the nation’s team, not an individual player.
Instead, the winner is a team, determined by cumulative points across multiple singles and doubles matches.

Therefore, for Question 2-b (counting how many players won multiple tournaments and identifying the player(s) with the most titles), the Laver Cup and The Davis Cup should be excluded from the statistics.
```{r q2b}
# Exclude Davis Cup and Laver Cup
ATP_clean <- ATP %>%
  filter(!grepl("2019-M-DC", tourney_id),
         tourney_id != "2019-9210")

# Tournament winners (Final round winners)
tourney_winners <- ATP_clean %>%
  filter(round == "F") %>%
  select(tourney_id, tourney_name, winner_id, winner_name) %>%
  distinct()

# Count titles per player
player_titles <- tourney_winners %>%
  group_by(winner_id, winner_name) %>%
  summarise(num_titles = n()) %>%
  ungroup()

# Players with more than one title
multiple_winners <- player_titles %>%
  filter(num_titles > 1)

# display Results
n_players_multiple <- nrow(multiple_winners)
max_titles <- max(player_titles$num_titles)

n_players_multiple
max_titles
```

**Answer:** There are 12 players won more than one tournament, and the most winning player won 5 tournaments.

### question 2-c
```{r q2c}
# Summarize mean and median aces
aces_summary <- ATP %>%
  summarise(
    mean_winner_aces = mean(w_ace, na.rm = TRUE),
    mean_loser_aces  = mean(l_ace, na.rm = TRUE),
    median_winner_aces = median(w_ace, na.rm = TRUE),
    median_loser_aces  = median(l_ace, na.rm = TRUE)
  )

print(aces_summary)

# Reshape to plot distributions
aces_long <- ATP %>%
  select(w_ace, l_ace) %>%
  rename(Winner = w_ace, Loser = l_ace) %>%
  tidyr::pivot_longer(cols = c(Winner, Loser), names_to = "Role", values_to = "Aces")

# Compare distributions
ggplot(aces_long, aes(x = Role, y = Aces, fill = Role)) +
  geom_boxplot() +
  labs(title = "Distribution of Aces: Winners vs Losers (2019)")
```

**Answer:** There is clear descriptive evidence that match winners tend to serve more aces than losers in 2019. While not a formal hypothesis test, the mean, median, and distribution comparisons all point in the same direction.

### question 2-d
For each player, the win rate = number of matches won / total matches played
```{r q2d}
# Wins per player
wins <- ATP %>%
  count(winner_name, name = "wins")

# Losses per player
losses <- ATP %>%
  count(loser_name, name = "losses")

# Combine and calculate win-rate
player_stats <- full_join(wins, losses,
                          by = c("winner_name" = "loser_name")) %>%
  rename(player = winner_name) %>%
  mutate(
    wins   = ifelse(is.na(wins), 0, wins),
    losses = ifelse(is.na(losses), 0, losses),
    total  = wins + losses,
    win_rate = wins / total
  ) %>%
  filter(total >= 5)

# Who has the highest win-rate?
top_players <- player_stats %>%
  filter(win_rate == max(win_rate, na.rm = TRUE))

top_players
```
**Answer:** As a result Rafael Nadal has the highest win-rate in tournament 2019.

\newpage

## Question 3
### laod NYTimes Covid data
```{r setup_question3}
covid <- readr::read_delim("https://raw.githubusercontent.com/nytimes/covid-19-data/refs/heads/master/rolling-averages/us.csv", show_col_types = FALSE)
```

### question 3-a
```{r q3a}
# Define percentile cutoffs
major_cutoff <- quantile(covid$cases_avg, probs = 0.95, na.rm = TRUE)
minor_cutoff <- quantile(covid$cases_avg, probs = 0.75, na.rm = TRUE)

covid_peaks <- covid %>%
  mutate(
    is_peak = cases_avg > lag(cases_avg) & cases_avg > lead(cases_avg),
    spike_type = case_when(
      is_peak & cases_avg >= major_cutoff ~ "Major spike",
      is_peak & cases_avg >= minor_cutoff ~ "Minor spike",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(spike_type)) %>%
  mutate(spike_type = factor(spike_type, levels = c("Major spike", "Minor spike")))

peak_counts <- covid_peaks %>%
  count(spike_type) %>%
  mutate(label = paste0(spike_type, ": ", n))

peak_counts

highlight_labels <- covid_peaks %>%
  filter(spike_type == "Major spike") %>%
  arrange(desc(cases_avg)) %>%
  slice_head(n = 5) %>%  # label the five largest major spikes
  mutate(
    label = paste0(
      format(date, "%b %Y"),
      "\n",
      scales::comma(round(cases_avg)),
      " cases"
    )
  )

covid %>%
  ggplot(aes(date, cases_avg)) +
  geom_line(color = "grey30", linewidth = 0.6) +
  geom_point(
    data = covid_peaks,
    aes(color = spike_type, size = spike_type),
    alpha = 0.85
  ) +
  scale_size_manual(values = c("Major spike" = 2.8, "Minor spike" = 1.6)) + 
  labs(
    title = "Identifying Major and Minor Spikes in US COVID-19 Cases",
    x = NULL,
    y = "average new cases",
    caption = "Source: NYTimes rolling averages. Major spikes >= 95th
  percentile; minor spikes between 75th and 95th percentiles."
  )

```

**Answer:** Personally, I set a peak as major peak when the `cases_avg` is larger than the 95% percentiles, and a peak as minor peak when `cases_avg` is between 75% and 95% percentiles. And there are 2 major peaks and 26 minor peaks

### question 3-b
```{r q3b}
# state level data
url <- "https://raw.githubusercontent.com/nytimes/covid-19-data/refs/heads/master/rolling-averages/us-states.csv"

covid_states <- read_csv(url, col_types = cols()) %>%
  mutate(date = as.Date(date))

# cases_avg_per_100k
cases_state_totals <- covid_states %>%
  group_by(state) %>%
  summarise(
    total_cases_per_100k = sum(cases_avg_per_100k, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(total_cases_per_100k))

cases_extreme_states <- bind_rows(
  slice_head(cases_state_totals, n = 1),
  slice_tail(cases_state_totals, n = 1)
) %>%
  pull(state)

plot_data <- covid_states %>%
  filter(state %in% cases_extreme_states)

ggplot(plot_data, aes(date, cases_avg_per_100k, color = state)) +
  geom_line(size = 0.9) +
  labs(
    title = "COVID-19 New Cases per 100,000 Residents",
    x = NULL,
    y = "avg new cases per 100k",
    color = "State",
  ) +
  scale_y_continuous(labels = number_format(accuracy = 1)) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "top",
    plot.title = element_text(face = "bold")
  )

# deaths_avg_per_100k
deaths_state_totals <- covid_states %>%
  group_by(state) %>%
  summarise(
    total_deaths_per_100k = sum(deaths_avg_per_100k, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(total_deaths_per_100k))

deaths_extreme_states <- bind_rows(
  slice_head(deaths_state_totals, n = 1),
  slice_tail(deaths_state_totals, n = 1)
) %>%
  pull(state)

plot_data <- covid_states %>%
  filter(state %in% deaths_extreme_states)

ggplot(plot_data, aes(date, deaths_avg_per_100k, color = state)) +
  geom_line(size = 0.9) +
  labs(
    title = "COVID-19 deaths per 100,000 Residents",
    x = NULL,
    y = "avg deaths per 100k",
    color = "State",
  ) +
  scale_y_continuous(labels = number_format(accuracy = 1)) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "top",
    plot.title = element_text(face = "bold")
  )
```

**Answer:** the provided data set is the national series, where one row per day for the entire country. So we need another data set with state-level data. [NYTimes Covid Data - State Level](https://raw.githubusercontent.com/nytimes/covid-19-data/refs/heads/master/rolling-averages/us-states.csv).

First, use the variable `cases_avg_per_100k`. Compared with these two different stats, where Rhode Island has the highest overall new cases rates per population and Maine has the lowest overall new cases rates per population, there is no big trend difference between these two. However, we can tell at similar timestamps, the Rhode Island usually has larger peaks compared with Maine.

Second, use the variable `deaths_avg_per_100k`. Compared with these two different stats, where Rhode Island has the lowest overall deaths rates per population and Arizona has the highest overall deaths rates per population, the Rhode Island's deaths rate in population has a peak in 2022, while the deaths rate for Arizona has three to four peaks around 2020.6, 2021.2, 2022.1, and 2023.1.

### question 3-c
```{r q3c}
threshold <- 20   # avg new cases per 100k interpreted as “substantial”
first_hits <- covid_states %>%
  filter(cases_avg_per_100k >= threshold) %>%
  group_by(state) %>%
  summarise(first_substantial = min(date), .groups = "drop") %>%
  arrange(first_substantial)

early_states <- first_hits %>%
  slice_head(n = 5) %>%
  pull(state)

plot_data <- covid_states %>%
  filter(state %in% early_states) %>%
  inner_join(first_hits, by = "state") %>%
  filter(date >= first_substantial - 7, date <= first_substantial + 21) %>%
  mutate(
    days_since_first = as.integer(date - first_substantial),
    state = fct_reorder(state, first_substantial)
  )

ggplot(plot_data, aes(days_since_first, cases_avg_per_100k, color = state)) +
  geom_hline(yintercept = threshold, linetype = "dashed", color = "grey50") +
  geom_line(size = 1) +
  geom_point(data = subset(plot_data, days_since_first == 0), size = 2) +
  labs(
    title = "Earliest States To See Sustained COVID-19 Spread",
    x = "Days Since First Substantial Spread",
    y = "Avg New Cases per 100k",
    color = "State"
    )
```

**Answer:** To answer this question, I set a threshold, which is 20 `cases_avg_per_100k`, representing a state starts to experience Covid. And then find the first date every states first hit the threshold, and arrange in an increasing sequence, to imformally identify the first five states.